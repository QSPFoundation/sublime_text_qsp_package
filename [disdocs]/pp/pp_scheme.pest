QspsPP {
  space := " " | "\t"    // не пропускаем \n/\r\n автоматически

  File = (Line newline?)* eof

  Line = CommentStmt | OtherStmt (stmtDelimiter (OtherStmt | CommentStmt))* | EmptyLine

  CommentStmt = (PpDirectiveLine | SpecialComment | SimpleComment) (&newline | &eof)

  PpDirectiveLine  = openDirectiveStmt PpDirective 
  SpecialComment = (lessSpecCommKwrd | simpleSpecCommKwrd) CommentBody
  SimpleComment = commentKwrd CommentBody

  // ---------------------------------- Any Comment Body ---------------------------------- //
    CommentBody = (commCodeBlock | rawStringLiteral | rawCommentChar)*

    commCodeBlock        = leftBrace commCodeBlockContent* rightBrace

    commCodeBlockContent = commCodeBlock
                        | rawStringLiteral
                        | commCodeBlockChar

    rawCommentChar = ~("{" | "}" | "'" | "\"") any
    
  // ---------------------------------- Any Comment Body ---------------------------------- //

  // ---- Specials Comments Tokens ----
  simpleSpecCommKwrd = "!@"
  lessSpecCommKwrd = "!@<"
  // ---- Specials Comments Tokens ----

  // Simple Comment Token
  commentKwrd = "!"

  // --------------------------------- PreProcessors Directives --------------------------------- //
    PpDirective = (DefineVarDirective
                | IfDirective
                | savecommStmt
                | noSavecommStmt
                | onStmt
                | offStmt
                | noppStmt
                | endifStmt)
        
    ConditionResolve = (onStmt
                      | offStmt
                      | savecommStmt
                      | noSavecommStmt
                      | noppStmt
                      | includeStmt
                      | excludeStmt)

    // complex
    IfDirective = ifStmt leftParen EqualExpression rightParen thenStmt ConditionResolve+
    DefineVarDirective = varStmt leftParen DefineVarExpression rightParen

    // define var
    DefineVarExpression = varName (assignmentOperator varName)?

    // Equal Expression
    EqualExpression = varName (logicOperator varName)*

    // unions
    logicOperator = (logicKwOperator | equalEqual | equalNotEqual)
    logicKwOperator = (andOperator | orOperator | notOperator)

    // Literals
    varName = ~logicOperator (alnum)+ // buildin instruction any letter
    

    // Tokens
    openDirectiveStmt = "!@pp:"
    // markers of commands
    ifStmt = "if"
    thenStmt = ":"
    varStmt = "var"
      // commands
      onStmt = "on"
      offStmt = "off"
      savecommStmt = "savecomm"
      noSavecommStmt = "nosavecomm"
      noppStmt = "nopp"
      includeStmt = "include"
      excludeStmt = "exclude"
      // signs
      assignmentOperator = "="
      equalEqual = "=="
      equalNotEqual = "!="
      andOperator = "and"
      orOperator = "or"
      notOperator = "not"

    endifStmt = "endif"

  // --------------------------------- PreProcessors Directives --------------------------------- //


  // ------------------------------------ Raw Strings ------------------------------------ //
    rawStringLiteral = rawApostrophedString | rawQuotedString

    rawApostrophedString = apostrophe (apostropheEscape | rawApostropheChar)* apostrophe
    rawQuotedString      = quote (quoteEscape | rawQuoteChar)* quote

    rawApostropheChar = ~apostrophe any
    rawQuoteChar      = ~quote any

    quoteEscape = "\"\""
    apostropheEscape = "''"
  // ------------------------------------ Raw Strings ------------------------------------ //

    // Tokens
    leftParen = "("
    rightParen = ")"
    leftBrace = "{"
    rightBrace = "}"
    leftBracket = "["
    rightBracket = "]"
    apostrophe = "'"
    quote = "\""
    

  // general rules
  rawChar = ~newline any
  anyLine = rawChar+

  // endings
  newline = "\r\n" | "\n" | "\r"
  eof = end
  
}